//! MediaRise Robot Console Backend Server
//!
//! Это главный файл приложения - точка входа в программу.
//! Backend сервер для управления устройствами MediaRise Robot (ESP32).
//! Сервер предоставляет HTTP API, WebSocket для голосового взаимодействия,
//! OTA обновления, управление устройствами и интеграцию с AI сервисами.

// Подключаем все модули проекта
// Модули - это отдельные файлы с кодом, которые мы используем в этом проекте
mod config;      // Модуль конфигурации - загрузка настроек из переменных окружения
mod handlers;     // HTTP обработчики - функции, которые обрабатывают HTTP запросы
mod mcp;          // MCP (Model Context Protocol) - протокол для работы с AI моделями
mod server;       // HTTP и WebSocket сервер - настройка маршрутов и запуск сервера
mod services;     // Бизнес-логика - сервисы для работы с LLM, STT, TTS, устройствами
mod storage;      // Хранилище данных - работа с базой данных и файлами
mod utils;        // Утилиты - вспомогательные функции (JWT, аудио обработка)
mod websocket;    // WebSocket обработка - работа с WebSocket соединениями

// Условная компиляция: этот модуль компилируется только если включена фича "mqtt"
// Фича - это опциональная функциональность, которую можно включить/выключить при сборке
#[cfg(feature = "mqtt")]
mod mqtt;         // MQTT протокол - для обмена сообщениями с устройствами через MQTT брокер

// Импортируем нужные типы и функции из библиотек
use anyhow::Result;  // Тип для возврата результата с ошибками (упрощенная обработка ошибок)
use tracing::{error, info};  // Функции для логирования (вывода информации в консоль)

// #[tokio::main] - это макрос, который превращает обычную функцию main в асинхронную
// Асинхронная функция может ждать выполнения других операций без блокировки потока
// Это нужно для работы с сетью, базой данных и другими I/O операциями
#[tokio::main]
async fn main() -> Result<()> {
    // ============================================
    // ШАГ 1: Инициализация системы логирования
    // ============================================
    // Логирование - это запись информации о работе программы в консоль или файл
    // Это помогает понять, что происходит в программе и найти ошибки
    
    // Создаем подписчика (subscriber) для логирования
    // Подписчик - это объект, который получает логи и выводит их куда-то (в консоль, файл и т.д.)
    tracing_subscriber::fmt()
        // Настраиваем фильтр логов - какие уровни логирования показывать
        // try_from_default_env() - пытается прочитать настройки из переменной окружения RUST_LOG
        // Если переменной нет, используем значение по умолчанию
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                // Если не удалось прочитать RUST_LOG, используем дефолтные настройки:
                // "xiaozhi_backend=info" - для нашего кода показываем уровень info и выше
                // "tower_http=debug" - для HTTP библиотеки показываем уровень debug и выше
                .unwrap_or_else(|_| "xiaozhi_backend=info,tower_http=debug".into()),
        )
        // Инициализируем систему логирования - теперь можно использовать info!, error! и т.д.
        .init();

    // Выводим информационное сообщение о запуске сервера
    info!("Starting MediaRise Robot Console Backend Server...");

    // ============================================
    // ШАГ 2: Загрузка конфигурации
    // ============================================
    // Конфигурация - это настройки программы (API ключи, адреса серверов, порты и т.д.)
    // Загружаем конфигурацию из переменных окружения или .env файла
    // ? - это оператор, который автоматически обрабатывает ошибки:
    // если load() вернет ошибку, функция main завершится с этой ошибкой
    let config = config::Config::load()?;
    
    // Выводим информацию о загруженной конфигурации
    // Это помогает убедиться, что все настройки загружены правильно
    info!(
        "Configuration loaded: STT provider={}, url={:?}, key_present={}, TTS provider={}, url={:?}, key_present={}",
        config.stt.provider,  // Провайдер STT (Speech-to-Text) - сервис для распознавания речи
        config.stt.api_url,  // URL API для STT
        // Проверяем, есть ли API ключ для STT (не пустой ли он)
        config.stt.api_key.as_ref().map(|k| !k.is_empty()).unwrap_or(false),
        config.tts.provider,  // Провайдер TTS (Text-to-Speech) - сервис для синтеза речи
        config.tts.api_url,   // URL API для TTS
        // Проверяем, есть ли API ключ для TTS
        config.tts.api_key.as_ref().map(|k| !k.is_empty()).unwrap_or(false),
    );

    // ============================================
    // ШАГ 3: Инициализация хранилища данных
    // ============================================
    // Хранилище - это объект для работы с базой данных и файлами
    // await - ждем завершения асинхронной операции
    // Storage::new() создает подключение к базе данных (SQLite, PostgreSQL или MySQL)
    let storage = storage::Storage::new(&config).await?;
    info!("Storage initialized");

    // ============================================
    // ШАГ 4: Инициализация сервисов
    // ============================================
    // Сервисы - это объекты с бизнес-логикой:
    // - LlmService - работа с языковыми моделями (Grok)
    // - SttService - распознавание речи (Whisper)
    // - TtsService - синтез речи (OpenAI TTS)
    // - DeviceService - управление устройствами
    // storage.clone() - создаем копию ссылки на хранилище (не копируем сами данные)
    let services = services::Services::new(&config, storage.clone()).await?;
    info!("Services initialized");

    // ============================================
    // ШАГ 5: Запуск MQTT сервиса (если включен)
    // ============================================
    // MQTT - это протокол для обмена сообщениями с IoT устройствами
    // #[cfg(feature = "mqtt")] - этот код компилируется только если включена фича "mqtt"
    #[cfg(feature = "mqtt")]
    {
        // Проверяем, есть ли конфигурация MQTT и включен ли он
        if let Some(mqtt_config) = &config.mqtt {
            if mqtt_config.enabled {
                info!("Starting MQTT service...");
                
                // Создаем MQTT сервис
                // with_services() и with_storage() - это паттерн "builder",
                // который позволяет настраивать объект пошагово
                let mut mqtt_service = mqtt::MqttService::new(mqtt_config)?
                    .with_services(services.clone())  // Передаем сервисы в MQTT
                    .with_storage(storage.clone());   // Передаем хранилище в MQTT

                // Запускаем MQTT в отдельной задаче (task)
                // tokio::spawn() - создает новую асинхронную задачу, которая выполняется параллельно
                // Это нужно, чтобы MQTT работал независимо от основного сервера
                tokio::spawn(async move {
                    // Запускаем MQTT сервис и обрабатываем ошибки
                    if let Err(e) = mqtt_service.start().await {
                        error!("MQTT service error: {}", e);
                    }
                });
                info!("MQTT service started");
            }
        }
    }

    // ============================================
    // ШАГ 6: Запуск HTTP и WebSocket сервера
    // ============================================
    // Запускаем основной сервер, который будет обрабатывать HTTP запросы и WebSocket соединения
    // server::start() - это функция, которая:
    // 1. Создает HTTP роутер (маршрутизатор запросов)
    // 2. Настраивает WebSocket endpoint
    // 3. Запускает сервер на указанном адресе и порту
    // 4. Начинает слушать входящие соединения
    if let Err(e) = server::start(config, services, storage).await {
        // Если произошла ошибка при запуске сервера, выводим её и завершаем программу
        error!("Server error: {}", e);
        return Err(e);
    }

    // Если всё прошло успешно, возвращаем Ok(())
    // В Rust Ok(()) означает успешное завершение без значения
    Ok(())
}
